import Inspect;
import System;

abstract class UnitTest {
    const METHOD_NAME_PADDING = '    ';
    const RESULTS_PADDING     = '    ';
    const ASSERTION_PADDING   = '         ';
    var forceOnlyFailures   = false;
    var forceExitOnFailure  = false;

    init(var onlyFailures = false, var exitOnFailure = false) {
        this.results = {
            'passed': 0,
            'failed': 0,
            'skipped': 0
        };
    }

    filterMethods() {
        return this.methods().filter(def (method) => {
            if (method.startsWith('test') and not method.endsWith('Provider') and not method.endsWith('_skipped')) {
                return method;
            }

            if (method.endsWith('_skipped')) {
                this.results['skipped'] += 1;
            }
        });
    }

    setUp() {

    }

    tearDown() {

    }

    run() {
        const methods = this.filterMethods();

        print(Inspect.getFile(1));
        methods.forEach(def (method) => {
            print('{}{}()'.format(UnitTest.METHOD_NAME_PADDING, method));

            const providerMethodName = '{}Provider'.format(method);

            if (this.hasAttribute(providerMethodName)) {
                const testValue = this.getAttribute(providerMethodName)();

                if (type(testValue) == 'list') {
                    testValue.forEach(def (val) => {
                        this.setUp();
                        this.getAttribute(method)(val);
                        this.tearDown();
                    });
                } else {
                    this.setUp();
                    this.getAttribute(method)(testValue);
                    this.tearDown();
                }
            } else {
                this.setUp();
                this.getAttribute(method)();
                this.tearDown();
            }
        });
        print('\nResults:\n{}- {} assertion(s) were successful.\n{}- {} assertion(s) were failures.\n{}- {} method(s) were skipped.\n'.format(
            UnitTest.RESULTS_PADDING,
            this.results['passed'],
            UnitTest.RESULTS_PADDING,
            this.results['failed'],
            UnitTest.RESULTS_PADDING,
            this.results['skipped']
        ));

        if (this.results['failed'] > 0) {
            System.exit(1);
        }
    }

    printResult(success, errorMsg, silent) {
        if (success) {
            this.results['passed'] += 1;

            if (not (this.onlyFailures or this.forceOnlyFailures) and not silent) {
                print('{}Success.'.format(UnitTest.ASSERTION_PADDING));
            }
        } else {
            this.results['failed'] += 1;

            print('{}Line: {} - {}'.format(UnitTest.ASSERTION_PADDING, Inspect.getLine(2), errorMsg));

            if (this.exitOnFailure or this.forceExitOnFailure) {
                System.exit(1);
            }
        }
    }

    assertEquals(value, expected, silent = false) {
        this.printResult(value == expected, 'Failure: {} is not equal to {}.'.format(value, expected), silent);
    }

    assertNotEquals(value, expected, silent = false) {
        this.printResult(value != expected, 'Failure: {} is equal to {}.'.format(value, expected), silent);
    }

    assertNil(value, silent = false) {
        this.printResult(value == nil, 'Failure: {} is not nil.'.format(value), silent);
    }

    assertNotNil(value, silent = false) {
        this.printResult(value != nil, 'Failure: Should not be nil.', silent);
    }

    assertType(value, expected, silent = false) {
        const valType = type(value);
        this.printResult(valType == expected, 'Failure: {}({}) is not of type {}.'.format(value, valType, expected), silent);
    }

    assertTruthy(value, silent = false) {
        this.printResult(value, 'Failure: {} is not Truthy.'.format(value), silent);
    }

    assertFalsey(value, silent = false) {
        this.printResult(not value, 'Failure: {} is not Falsey.'.format(value), silent);
    }

    assertSuccess(value, silent = false) {
        if (type(value) != 'result') {
            this.printResult(false, 'Failure: {} is not a Result type.'.format(value), silent);
            return;
        }

        this.printResult(value.success(), 'Failure: {} is not a Result type in a success state.'.format(value), silent);
    }

    assertError(value, silent = false) {
        if (type(value) != 'result') {
            this.printResult(false, 'Failure: {} is not a Result type.'.format(value), silent);
            return;
        }

        this.printResult(not value.success(), 'Failure: {} is not a Result type in an error state.'.format(value), silent);
    }
}